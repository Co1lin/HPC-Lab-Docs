# 实验一：odd_even_sort（奇偶排序）

负责助教：金煜阳 jyy17@mails.tsinghua.edu.cn

通过实现奇偶排序帮助熟悉`MPI`。在保证正确性的前提下，我们鼓励通过探索不同的并行化策略以优化程序性能。



## 1. 背景介绍

使用`MPI`实现奇偶排序算法，**`MPI`进程只能向其相邻进程发送消息**。
奇偶排序是一种比较排序，它由两个主要阶段组成：**偶数阶段** 和 **奇数阶段** 。在偶数阶段，比较所有相邻元素的偶数/奇数索引对。如果一对顺序错误，则将切换元素。类似地，对奇数阶段中的奇数/偶数索引对重复相同的过程。奇偶排序算法的工作原理是将这两个阶段交替进行，直到序列排序完成为止。
为了更好地理解该算法，下面逐步说明了奇偶排序的执行流程：（在以下示例中，我们将序列按升序排序）

1. [偶数阶段] 满足(偶数，奇数)索引的相邻元素组成元素对。
```python
   Index    0   1   2   3   4   5   6   7
   Value   (6   1) (4   8) (2   5) (9   3)
```
2. [偶数阶段] 如果元素对中存在顺序错误，则交换两个元素。
```python
   Index    0   1   2   3   4   5   6   7
   Value   (1   6) (4   8) (2   5) (3   9)
```
3. [奇数阶段] 满足(奇数，偶数)索引相邻元素被组成元素对。
```python
   Index    0   1   2   3   4   5   6   7
   Value    1  (6   4) (8   2) (5   3)  9
```
4. [奇数阶段] 如果元素对中存在顺序错误，则交换两个元素。
```python
   Index    0   1   2   3   4   5   6   7
   Value    1  (4   6) (2   8) (3   5)  9
```
5. 交替运行偶数阶段和奇数阶段，直到偶数阶段和奇数阶段都 **没有元素交换**。

接下来，提供一种并行化的奇偶排序思路：（在以下示例中，我们将序列按升序排序）

1. 进程内排序。
```python
Process     0         1         2         3          4           5          6           7
Value   |6 8 3 5| |9 4 1 7| |8 2 1 7| |3 5 2 9| |8 11 4 29| |34 1 4 56| |5 7 6 11|  |10 9 5 2| （排序前）
Value   |3 5 6 8| |1 4 7 9| |1 2 7 8| |3 5 2 9| |4 8 11 29| |1 4 34 56| |5 6 7 11|  |2 5 9 10| （排序后）
```
2. [偶数阶段] 满足 `(偶数，奇数)` 索引的相邻进程组成进程对。
```python
Process      0         1           2         3            4           5            6          7
Value   (|3 5 6 8| |1 4 7 9|) (|1 2 7 8| |3 5 2 9|) (|4 8 11 29| |1 4 34 56|) (|5 6 7 11| |2 5 9 10|) 
```
3. [偶数阶段] 如果偶数进程的最大值大于奇数进程的最小值，则合并、排序两个进程的序列并重新分配至进程中（元素交换）。
```python
Process     0           1          2         3           4           5             6          7
Value   (|1 3 4 5   6 7 8 9|) (|1 2 2 3   5 7 8 9|) (|1 4 4 8   11 29 34 56|) (|2 5 5 6   7 9 10 11|) （合并排序）
Value   (|1 3 4 5| |6 7 8 9|) (|1 2 2 3| |5 7 8 9|) (|1 4 4 8| |11 29 34 56|) (|2 5 5 6| |7 9 10 11|) （重新分配）
```
4. [奇数阶段] 满足 `(奇数，偶数)` 索引的相邻进程组成进程对。
```python
Process     0          1         2           3         4             5           6           7
Value   |1 3 4 5| (|6 7 8 9| |1 2 2 3|) (|5 7 8 9| |1 4 4 8|) (|11 29 34 56| |2 5 5 6|) |7 9 10 11|
```
5. [奇数阶段] 如果奇数进程的最大值大于偶数进程的最小值，则合并、排序两个进程的序列并重新分配至进程中（元素交换）。
```python
Process     0          1         2           3         4           5           6             7
Value   |1 3 4 5| (|1 2 2 3   6 7 8 9|) (|1 4 4 5   7 8 8 9|) (|2 5 5 6   11 29 34 56|) |7 9 10 11| （合并排序）
Value   |1 3 4 5| (|1 2 2 3| |6 7 8 9|) (|1 4 4 5| |7 8 8 9|) (|2 5 5 6| |11 29 34 56|) |7 9 10 11| （重新分配）
```
6. 交替运行偶数阶段和奇数阶段，直到偶数阶段和奇数阶段都**没有元素交换**。



## 2. 实验步骤

首先将实验文件 **拷贝到自己的目录** ，并进入 `PA1` 目录：

```bash
$ cp -R /home/course/hpc/assignments/2021/PA1 ~/
$ cd ~/PA1/
```



### 2.1 运行流程

1. 运行二进制文件`generate`生成乱序序列作为输入：
```bash
$ ./generate <number_of_elements> <file>
```
其中两个参数的含义分别是：
    * `number_of_elements`: 生成的乱序序列的元素个数 n（0 ≤ n ≤ 2147483647）；
    * `file`: 存储乱序序列的输出文件名。

具体运行命令，例如：
```bash
$ mkdir data
$ ./generate 256 ./data/input.dat
```
2. 运行二进制文件`odd_even_sort`对输入文件中的乱序序列进行排序：
```bash
$ srun -n <nprocs> ./odd_even_sort <number_of_elements> <input_file>
```
其中三个参数的含义分别是：  
    * `nprocs` : 运行的进程数；
    * `number_of_elements` : 输入乱序序列的元素个数 n（0 ≤ n ≤ 2147483647）；
    * `input_file` : 输入文件名（如 `generate` 的输出文件），输入文件列出了 n 个 32 位浮点数（二进制格式）。请参考输入文件 `./data/example_input.txt`。
具体运行命令，例如：

```bash
$ srun -n 4 ./odd_even_sort 256 ./data/input.dat
```


### 2.2 具体任务

1. **填写`odd_even_sort.cpp`文件中的`sort`函数。在该函数内实现并行化的奇偶排序算法（具体请见背景介绍）。**
2. 采用升序排列。
3. 框架首先读入输入文件中的序列，每个进程分别读入序列的一部分。
4. 框架将在排序之后进行检验，只有所有进程都输出 pass 才表示排序后序列通过检验，存在错误顺序的将输出 failed 。正确输出如下：
```bash
...
Rank 0: pass
Rank 1: pass
rank 2: pass
Rank 3: pass
...
```



### 2.3 优化策略

1. 可以尝试将计算时间和通信时间尽可能地重叠。
2. 可以尝试使迭代之间的操作重叠。
3. **如果不确定自己的优化方法或实现是否符合规则，请与助教进行讨论。**



### 2.4 注意事项
1. 除`odd_even_sort.cpp`外其他文件的代码不可以改动，擅自改动可能导致判分时的正确性问题。
2. 运行流程中步骤1（生成乱序序列）用于同学们的自测试。判分的测试数据不完全由`generate`生成，但判分的测试数据将是固定的10组数据，并满足步骤2的输入条件。
3. **运行流程中步骤2中的二进制文件`odd_even_sort`，需在填写`odd_even_sort.cpp`文件中的`sort`函数后才可编译生成。**



## 3. 分数细则

1. 正确性（80％）
   + 共10组测试用例。您将获得通过的测试用例的分数，每个测试用例分数相同。
   + 在作业截止日期之后进行正确性检查。
   + **截止日期3天后提交的任何正确结果将仅获得X0％的分数。**
   
2. 性能（10％）
   + 性能测试只针对 `sort` 函数，即仅对 `sort` 函数计时。
   + **分数是根据XXX给出**。

3. 实验报告（10％）
   + 助教根据实验报告的完整性给出分数，需要写的内容在下面给出。



## 4. 实验提交

1. 实验代码与结果：
    * 在截止日期之前将完成后的整个实验框架置于自己 home 目录下的 `PA1` 文件夹，如 `/home/course/hpc/users/2020000000/PA1`。  
    * 只允许修改 `odd_even_sort.cpp` 文件中的 `sort` 函数。
2. 实验报告：
    * 将 **PDF 文件** 提交至网络学堂（无需代码）。
    * 包含以下内容：
        1. `odd_even_sort.cpp` 中 `sort` 函数的源代码，并给出简要注释。 
        3. 报告 1 x 1, 1 x 2, 1 x 4, 1 x 8, 1 x 16, 2 x16 进程（N x P 表示 N 台机器，每台机器  P 个进程）**在 n = XX 下sort函数的运行时间，及相对单进程的加速比。**


